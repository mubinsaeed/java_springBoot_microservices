current video 34


How the microservices can communicate
1) Using the RestTemplate
2) Using the service discovery
3) Using the openFeign


Why service discovery is needed?
Suppose that there are two instances of fraud module the customer module need to know about all the fraud modules
and its ports. A better approach would be to have a service discovery like Eureka server and client(microservices)

Through lookup they can do that

ISSUE with this: If the main eureka server i.e service discovery is down there is no way for microservices to communicate

---------------------------Using the restTemplate------------------------
 fraudResponse response = restTemplate.getForObject("http://localhost:8081/api/fraud-check/{id}", fraudResponse.class,
                customer.getId());

 Here we are consuming the service from fraud
 However the issue is that if there are multiple instances of fraud module we cannot hardcode the api as localhost:8080
 There could be multiple ports that run the instances


 RESOLVE: It by using the eureka server i.e service discovery
 The call changes to  fraudResponse response = restTemplate.getForObject("http://fraud:8081/api/fraud-check/{id}", fraudResponse.class,
                                     customer.getId());


------------------Refactoriing the code by OPEN FEIGN To create a client ------------------------
Why needed?
    Previously we need to create a redundant fraudResponse interface in both customer and fraud package
     fraudResponse response = restTemplate.getForObject("http://fraud/api/fraud-check/{id}", fraudResponse.class,
                    customer.getId());
We would have needed the above code to access the url but using previous technique we have to duplicate the Response Class again

Better approach is to create an open feign client

Post req at url: localhost:8080/api/v1/customers
Request Body: {
              "firstName":"ABC",
              "lastName":"CBA",
              "email" : "abc@gmail.com"
              }

Making this request would result in populating the fields of customer , notifications and fraud table.




----------------------Distributed Tracing Using the Cloud Sleuth and Zipkins--------------------------------
For the cloud Sleuth:
    There are two params trace id and span id                            trace id    span id
    Example: on terminal when the module is run it shows INFO[customer,19sdfdfsdfsd,s2efsfdsdsfsdf]

    Following is been printed because we have inserted log.info(.....) in the code.

WHY this tracing is needed?
    When there are different microservices having multiple instances and we dont know which of the instance
    get down of which of the module therefore we use that to identify the entire trace route of the request



----------------LOAD BALANCING ---------------------------------
When there are thousands of customer accessing the webapp either can can deploy that on very high specs single pc
But it won't cater the need when customer access grows

The possible solution to this is to have multiple instances of that running
Issue the customer don't know which instance to connect therefore there is load balancer.

HOW load balancer decides which instance to send the request to?
They uses multiple routing algorithms most commonly round robin, least connections, least time, hash etc
